package md2pdf

import (
	"fmt"
	"strings"

	"github.com/jung-kurt/gofpdf"
	. "github.com/tcd/md2pdf/internal/ghfm"
	"golang.org/x/net/html"
)

// [] BlockCode(out *bytes.Buffer, text []byte, infoString string)
// [] BlockQuote(out *bytes.Buffer, text []byte)
// [] BlockHtml(out *bytes.Buffer, text []byte)
// [x] Header(out *bytes.Buffer, text func() bool, level int, id string)
// [] HRule(out *bytes.Buffer)
// [] List(out *bytes.Buffer, text func() bool, flags int)
// [] ListItem(out *bytes.Buffer, text []byte, flags int)
// [] Paragraph(out *bytes.Buffer, text func() bool)
// [] Table(out *bytes.Buffer, header []byte, body []byte, columnData []int)
// [] TableRow(out *bytes.Buffer, text []byte)
// [] TableHeaderCell(out *bytes.Buffer, text []byte, flags int)
// [] TableCell(out *bytes.Buffer, text []byte, flags int)
// [] Footnotes(out *bytes.Buffer, text func() bool)
// [] FootnoteItem(out *bytes.Buffer, name, text []byte, flags int)
// [] TitleBlock(out *bytes.Buffer, text []byte)
// [] AutoLink(out *bytes.Buffer, link []byte, kind int)
// [] CodeSpan(out *bytes.Buffer, text []byte)
// [] DoubleEmphasis(out *bytes.Buffer, text []byte)
// [] Emphasis(out *bytes.Buffer, text []byte)
// [] Image(out *bytes.Buffer, link []byte, title []byte, alt []byte)
// [] LineBreak(out *bytes.Buffer)
// [] Link(out *bytes.Buffer, link []byte, title []byte, content []byte)
// [] RawHtmlTag(out *bytes.Buffer, tag []byte)
// [] TripleEmphasis(out *bytes.Buffer, text []byte)
// [] StrikeThrough(out *bytes.Buffer, text []byte)
// [] FootnoteRef(out *bytes.Buffer, ref []byte, id int)
// [] Entity(out *bytes.Buffer, entity []byte)
// [] NormalText(out *bytes.Buffer, text []byte)

// Parse renders a PDF from an html string generated by blackfriday
//
// TODO: Clean html first? gofpdf can only render a limited set of characters.
func Parse(inputHTML, outputPath string) error {

	doc := strings.NewReader(inputHTML)
	tokenizer := html.NewTokenizer(doc)
	pdf := gofpdf.New("P", "mm", "Letter", "")
	Setup(pdf)

	for {
		tt := tokenizer.Next()

		if tt == html.ErrorToken {
			break
		}

		if tt == html.SelfClosingTagToken {
			T1 := tokenizer.Token()

			if T1.Data == "hr" {
				HR(pdf)
			}
		}

		if tt == html.StartTagToken {
			T1 := tokenizer.Token()

			if T1.Data == "p" {
				parseP(pdf, tokenizer)
			}

			if T1.Data == "h1" {
				parseH1(pdf, tokenizer)
			}
			if T1.Data == "h2" {
				parseH2(pdf, tokenizer)
			}
			if T1.Data == "h3" {
				parseH3(pdf, tokenizer)
			}
			if T1.Data == "h4" {
				parseH4(pdf, tokenizer)
			}
			if T1.Data == "h5" {
				parseH5(pdf, tokenizer)
			}
			if T1.Data == "h6" {
				parseH6(pdf, tokenizer)
			}
		}
	}

	err := pdf.OutputFileAndClose(outputPath)
	if err != nil {
		return err
	}
	return nil
}

// func parse(pdf *gofpdf.Fpdf, z *html.Tokenizer) {}

func parseH1(pdf *gofpdf.Fpdf, z *html.Tokenizer) {
	tt := z.Next()
	if tt == html.TextToken {
		content := z.Text()
		H1(pdf, string(content))
	}
}
func parseH2(pdf *gofpdf.Fpdf, z *html.Tokenizer) {
	tt := z.Next()
	if tt == html.TextToken {
		content := z.Text()
		H2(pdf, string(content))
	}
}
func parseH3(pdf *gofpdf.Fpdf, z *html.Tokenizer) {
	tt := z.Next()
	if tt == html.TextToken {
		content := z.Text()
		H3(pdf, string(content))
	}
}
func parseH4(pdf *gofpdf.Fpdf, z *html.Tokenizer) {
	tt := z.Next()
	if tt == html.TextToken {
		content := z.Text()
		H4(pdf, string(content))
	}
}
func parseH5(pdf *gofpdf.Fpdf, z *html.Tokenizer) {
	tt := z.Next()
	if tt == html.TextToken {
		content := z.Text()
		H5(pdf, string(content))
	}
}
func parseH6(pdf *gofpdf.Fpdf, z *html.Tokenizer) {
	tt := z.Next()
	if tt == html.TextToken {
		content := z.Text()
		H6(pdf, string(content))
	}
}

func parseP(pdf *gofpdf.Fpdf, z *html.Tokenizer) {

	tt := z.Next()

	if tt == html.TextToken {
		// content := z.Text()
		// fmt.Println(string(content))
	}

	if tt == html.StartTagToken {
		T1 := z.Token()

		if T1.Data == "a" {
			parseA(pdf, z, T1)
		}
	}
}

func parseA(pdf *gofpdf.Fpdf, z *html.Tokenizer, token html.Token) {
	var content, href string

	for _, a := range token.Attr {
		if a.Key == "href" {
			href = a.Val
		}
	}

	tt := z.Next()
	if tt == html.StartTagToken {
		fmt.Println("Aint nobody got time for that")
	}
	if tt == html.TextToken {
		T1 := z.Text()
		tt2 := z.Next()
		if tt2 == html.EndTagToken {
			content = string(T1)
		} else {
			fmt.Println("Aint nobody got time for that")
		}
	}

	link(pdf, content, href)
}

func parseEm(pdf *gofpdf.Fpdf, z *html.Tokenizer) {

}

func parseStrong(pdf *gofpdf.Fpdf, z *html.Tokenizer) {

}

func parseDel(pdf *gofpdf.Fpdf, z *html.Tokenizer) {

}

func parseCode(pdf *gofpdf.Fpdf, z *html.Tokenizer) {

}

func parseHR(pdf *gofpdf.Fpdf, z *html.Tokenizer) {

}
